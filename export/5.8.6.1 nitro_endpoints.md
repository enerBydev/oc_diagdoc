---
id: 5.8.6.1
title: Nitro Endpoints
parent: 5.8.6
breadcrumb: 0 → 5.0 → 5.8 → 5.8.6 → 5.8.6.1
type: api
status: activo
last_updated: 2026-01-29 15:32
file_create: 2026-01-01 18:10
domain:
- nitro
- endpoints
- ubicacion
summary: Endpoints Nitro para ubicaciones.
content_hash: 5f7d85f6ad55cd0e
---

# 5.8.6.1 Nitro Endpoints

API routes para geolocalización usando Nitro v3.

---

## Estructura de Archivos

```
server/
├── api/
│   └── ubicacion/
│       ├── [servicioId]/
│       │   ├── actual.get.ts      # GET última ubicación
│       │   ├── historial.get.ts   # GET historial ubicaciones
│       │   └── index.post.ts      # POST nueva ubicación
│       └── broadcast.post.ts      # POST broadcast manual
├── utils/
│   └── geo-validation.ts          # Validadores
└── middleware/
    └── geo-auth.ts                # Auth middleware
```

---

## Endpoint: Obtener Última Ubicación

```typescript
// server/api/ubicacion/[servicioId]/actual.get.ts
import { serverSupabaseClient } from '#supabase/server';

export default defineEventHandler(async (event) => {
  const servicioId = getRouterParam(event, 'servicioId');
  
  // Validar UUID
  if (!isValidUUID(servicioId)) {
    throw createError({ statusCode: 400, message: 'ID inválido' });
  }
  
  const supabase = await serverSupabaseClient(event);
  
  // Intentar primero desde cache KV (Cloudflare)
  const cached = await useStorage('kv').getItem(`ubicacion:${servicioId}`);
  if (cached) {
    return cached;
  }
  
  // Fallback a base de datos
  const { data, error } = await supabase
    .from('ultima_ubicacion_operador')
    .select('*')
    .eq('servicio_id', servicioId)
    .single();
  
  if (error) {
    throw createError({ statusCode: 404, message: 'Ubicación no encontrada' });
  }
  
  return data;
});
```

---

## Endpoint: Guardar Nueva Ubicación

```typescript
// server/api/ubicacion/[servicioId]/index.post.ts
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server';
import { z } from 'zod';

const ubicacionSchema = z.object({
  lat: z.number().min(-90).max(90),
  lng: z.number().min(-180).max(180),
  accuracy: z.number().min(0).optional(),
  timestamp: z.number().optional()
});

export default defineEventHandler(async (event) => {
  const servicioId = getRouterParam(event, 'servicioId');
  const body = await readBody(event);
  
  // Validar payload
  const result = ubicacionSchema.safeParse(body);
  if (!result.success) {
    throw createError({ 
      statusCode: 400, 
      message: 'Payload inválido',
      data: result.error.flatten()
    });
  }
  
  const { lat, lng, accuracy } = result.data;
  
  // Verificar usuario autenticado
  const user = await serverSupabaseUser(event);
  if (!user) {
    throw createError({ statusCode: 401, message: 'No autenticado' });
  }
  
  // Verificar que es el operador del servicio
  const supabase = await serverSupabaseClient(event);
  const { data: servicio } = await supabase
    .from('servicios')
    .select('operador_id, estado')
    .eq('id', servicioId)
    .single();
  
  if (!servicio || servicio.operador_id !== user.id) {
    throw createError({ statusCode: 403, message: 'No autorizado' });
  }
  
  if (servicio.estado !== 'en_camino') {
    throw createError({ statusCode: 400, message: 'Servicio no está en camino' });
  }
  
  // Guardar en base de datos
  const { error: insertError } = await supabase
    .from('ubicaciones_servicio')
    .insert({
      servicio_id: servicioId,
      operador_id: user.id,
      lat,
      lng,
      accuracy: accuracy ?? null
    });
  
  if (insertError) {
    throw createError({ statusCode: 500, message: 'Error al guardar' });
  }
  
  // Actualizar cache KV
  await useStorage('kv').setItem(`ubicacion:${servicioId}`, {
    lat, lng, accuracy, timestamp: Date.now()
  }, { ttl: 300 }); // 5 minutos TTL
  
  return { success: true };
});
```

---

## Endpoint: Historial de Ubicaciones

```typescript
// server/api/ubicacion/[servicioId]/historial.get.ts
export default defineEventHandler(async (event) => {
  const servicioId = getRouterParam(event, 'servicioId');
  const query = getQuery(event);
  
  const limit = Math.min(parseInt(query.limit as string) || 100, 500);
  const offset = parseInt(query.offset as string) || 0;
  
  const supabase = await serverSupabaseClient(event);
  
  const { data, error, count } = await supabase
    .from('ubicaciones_servicio')
    .select('lat, lng, accuracy, timestamp', { count: 'exact' })
    .eq('servicio_id', servicioId)
    .order('timestamp', { ascending: false })
    .range(offset, offset + limit - 1);
  
  if (error) {
    throw createError({ statusCode: 500, message: error.message });
  }
  
  return {
    data,
    pagination: {
      total: count,
      limit,
      offset,
      hasMore: (count ?? 0) > offset + limit
    }
  };
});
```

---

## Middleware de Autenticación

```typescript
// server/middleware/geo-auth.ts
export default defineEventHandler(async (event) => {
  // Solo aplicar a rutas de ubicación
  if (!event.path.startsWith('/api/ubicacion')) return;
  
  // Verificar header de autorización
  const authHeader = getHeader(event, 'authorization');
  if (!authHeader?.startsWith('Bearer ')) {
    throw createError({ statusCode: 401, message: 'Token requerido' });
  }
  
  // La validación real la hace Supabase
});
```

---

## Validadores

```typescript
// server/utils/geo-validation.ts
export const isValidUUID = (str: string): boolean => {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidRegex.test(str);
};

export const isValidCoordinate = (lat: number, lng: number): boolean => {
  return lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
};

export const sanitizeCoordinates = (lat: number, lng: number) => ({
  lat: Math.round(lat * 1e8) / 1e8,  // 8 decimales
  lng: Math.round(lng * 1e8) / 1e8
});
```

---

## Rate Limiting

```typescript
// server/middleware/rate-limit-geo.ts
const rateLimits = new Map<string, { count: number; resetAt: number }>();

export default defineEventHandler(async (event) => {
  if (!event.path.includes('/ubicacion')) return;
  
  const user = await serverSupabaseUser(event);
  if (!user) return;
  
  const key = `geo:${user.id}`;
  const now = Date.now();
  const limit = rateLimits.get(key);
  
  // 60 requests por minuto
  if (limit && limit.resetAt > now) {
    if (limit.count >= 60) {
      throw createError({ statusCode: 429, message: 'Demasiadas solicitudes' });
    }
    limit.count++;
  } else {
    rateLimits.set(key, { count: 1, resetAt: now + 60000 });
  }
});
```

---

→ Ver schema: [[Proyecto OnlyCarNLD/Datos/5.8.6.2 supabase_schema]]

---

## Navegación

| ⬆️ Padre             | [[Proyecto OnlyCarNLD/Datos/5.8.6 backend_ubicaciones]]            |
| -------------------- | ---------------------- |
| ➡️ Hermano siguiente | [[Proyecto OnlyCarNLD/Datos/5.8.6.2 supabase_schema]]              |
