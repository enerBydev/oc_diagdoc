---
id: 3.1.7.6
title: Esquema SQL - Sistema de Costos
parent: 3.1.7
breadcrumb: 0 → 3.0 → 3.1 → 3.1.7 → 3.1.7.6
type: hoja
status: activo
last_updated: 2026-01-29 15:32
file_create: 2025-12-17 11:51
domain:
- sql
- supabase
- schema
actors:
- admin
summary: 'Esquema SQL completo del sistema de costos.

  Tablas, vistas, funciones y RLS.'
content_hash: d062abdcffebb776
---

# 3.1.7.6 Esquema SQL - Sistema de Costos

**Stack:** Supabase/PostgreSQL  
**Seguridad:** RLS habilitado - Solo rol `admin`

---

### Tablas

#### 1. tipos_costo

```sql
-- Categorías de costos
CREATE TABLE IF NOT EXISTS tipos_costo (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  nombre VARCHAR(100) NOT NULL UNIQUE,
  categoria VARCHAR(20) NOT NULL CHECK (categoria IN ('variable', 'fijo')),
  icono VARCHAR(50) DEFAULT 'circle',
  orden INTEGER DEFAULT 0,
  activo BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Datos iniciales
INSERT INTO tipos_costo (nombre, categoria, icono, orden) VALUES
  ('Insumo', 'variable', 'droplet', 1),
  ('Mano de Obra', 'variable', 'user', 2),
  ('Desgaste de Equipo', 'variable', 'tool', 3),
  ('Operación', 'fijo', 'truck', 4),
  ('Marketing', 'fijo', 'megaphone', 5),
  ('Administración', 'fijo', 'building', 6);
```

---

#### 2. recursos

```sql
-- Catálogo de recursos/insumos
CREATE TABLE IF NOT EXISTS recursos (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tipo_costo_id UUID NOT NULL REFERENCES tipos_costo(id) ON DELETE RESTRICT,
  nombre VARCHAR(200) NOT NULL,
  descripcion TEXT,
  unidad VARCHAR(30) NOT NULL,
  costo_unitario DECIMAL(12,4) NOT NULL CHECK (costo_unitario >= 0),
  proveedor VARCHAR(200),
  sku VARCHAR(100),
  activo BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Índices
CREATE INDEX idx_recursos_tipo ON recursos(tipo_costo_id);
CREATE INDEX idx_recursos_activo ON recursos(activo) WHERE activo = true;
```

---

#### 3. costos_servicio

```sql
-- Asignación de costos variables a servicios
CREATE TABLE IF NOT EXISTS costos_servicio (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  servicio_id VARCHAR(100) NOT NULL,
  recurso_id UUID NOT NULL REFERENCES recursos(id) ON DELETE CASCADE,
  cantidad DECIMAL(12,4) NOT NULL CHECK (cantidad > 0),
  notas TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(servicio_id, recurso_id)
);

CREATE INDEX idx_costos_servicio ON costos_servicio(servicio_id);
```

---

#### 4. costos_fijos

```sql
-- Costos fijos mensuales
CREATE TABLE IF NOT EXISTS costos_fijos (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tipo_costo_id UUID REFERENCES tipos_costo(id),
  nombre VARCHAR(200) NOT NULL,
  descripcion TEXT,
  monto_mensual DECIMAL(12,2) NOT NULL CHECK (monto_mensual >= 0),
  frecuencia VARCHAR(20) DEFAULT 'mensual' CHECK (frecuencia IN ('mensual', 'anual')),
  activo BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

---

#### 5. config_margenes

```sql
-- Configuración de márgenes objetivo
CREATE TABLE IF NOT EXISTS config_margenes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  margen_minimo DECIMAL(5,2) DEFAULT 40 CHECK (margen_minimo >= 0 AND margen_minimo <= 100),
  margen_optimo DECIMAL(5,2) DEFAULT 55 CHECK (margen_optimo >= 0 AND margen_optimo <= 100),
  margen_maximo DECIMAL(5,2) DEFAULT 70 CHECK (margen_maximo >= 0 AND margen_maximo <= 100),
  servicios_estimados_mes INTEGER DEFAULT 150 CHECK (servicios_estimados_mes > 0),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  updated_by UUID REFERENCES auth.users(id)
);

-- Solo puede existir un registro
INSERT INTO config_margenes (id) VALUES (gen_random_uuid()) ON CONFLICT DO NOTHING;
```

---

#### 6. historial_precios

```sql
-- Historial de cambios de precios (auditoría)
CREATE TABLE IF NOT EXISTS historial_precios (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  servicio_id VARCHAR(100) NOT NULL,
  precio_anterior DECIMAL(12,2),
  precio_nuevo DECIMAL(12,2) NOT NULL,
  costo_total_momento DECIMAL(12,2),
  margen_momento DECIMAL(5,2),
  motivo TEXT,
  aplicado_por UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_historial_servicio ON historial_precios(servicio_id, created_at DESC);
```

---

### Vistas

#### v_costos_fijos_total

```sql
-- Suma de costos fijos mensuales
CREATE OR REPLACE VIEW v_costos_fijos_total AS
SELECT 
  SUM(
    CASE 
      WHEN frecuencia = 'anual' THEN monto_mensual / 12
      ELSE monto_mensual
    END
  ) as total_mensual
FROM costos_fijos
WHERE activo = true;
```

---

#### v_analisis_costos

```sql
-- Análisis completo por servicio
CREATE OR REPLACE VIEW v_analisis_costos AS
WITH costos_variables AS (
  SELECT
    cs.servicio_id,
    SUM(cs.cantidad * r.costo_unitario) as costo_variable
  FROM costos_servicio cs
  JOIN recursos r ON cs.recurso_id = r.id
  WHERE r.activo = true
  GROUP BY cs.servicio_id
),
fijos AS (
  SELECT total_mensual FROM v_costos_fijos_total
),
config AS (
  SELECT servicios_estimados_mes, margen_minimo, margen_optimo, margen_maximo
  FROM config_margenes
  LIMIT 1
)
SELECT
  cv.servicio_id,
  ROUND(cv.costo_variable, 2) as costo_variable,
  ROUND(f.total_mensual / c.servicios_estimados_mes, 2) as costo_fijo_prorrateado,
  ROUND(cv.costo_variable + (f.total_mensual / c.servicios_estimados_mes), 2) as costo_total,
  c.margen_minimo,
  c.margen_optimo,
  c.margen_maximo,
  -- Precios sugeridos (redondeados al múltiplo de 10)
  ROUND((cv.costo_variable + (f.total_mensual / c.servicios_estimados_mes)) / (1 - c.margen_minimo / 100) / 10) * 10 as precio_sugerido_minimo,
  ROUND((cv.costo_variable + (f.total_mensual / c.servicios_estimados_mes)) / (1 - c.margen_optimo / 100) / 10) * 10 as precio_sugerido_optimo,
  ROUND((cv.costo_variable + (f.total_mensual / c.servicios_estimados_mes)) / (1 - c.margen_maximo / 100) / 10) * 10 as precio_sugerido_maximo
FROM costos_variables cv
CROSS JOIN fijos f
CROSS JOIN config c;
```

---

### Funciones

#### fn_precio_sugerido

```sql
-- Calcular precio sugerido con margen personalizado
CREATE OR REPLACE FUNCTION fn_precio_sugerido(
  p_servicio_id VARCHAR,
  p_margen DECIMAL
) RETURNS DECIMAL AS $$
DECLARE
  v_costo_total DECIMAL;
BEGIN
  SELECT costo_total INTO v_costo_total
  FROM v_analisis_costos
  WHERE servicio_id = p_servicio_id;
  
  IF v_costo_total IS NULL THEN
    RETURN NULL;
  END IF;
  
  RETURN ROUND(v_costo_total / (1 - p_margen / 100) / 10) * 10;
END;
$$ LANGUAGE plpgsql STABLE;
```

---

#### fn_registrar_cambio_precio

```sql
-- Registrar cambio de precio en historial
CREATE OR REPLACE FUNCTION fn_registrar_cambio_precio(
  p_servicio_id VARCHAR,
  p_precio_anterior DECIMAL,
  p_precio_nuevo DECIMAL,
  p_motivo TEXT,
  p_user_id UUID
) RETURNS UUID AS $$
DECLARE
  v_costo_total DECIMAL;
  v_margen DECIMAL;
  v_id UUID;
BEGIN
  SELECT costo_total INTO v_costo_total
  FROM v_analisis_costos
  WHERE servicio_id = p_servicio_id;
  
  v_margen := ROUND(((p_precio_nuevo - COALESCE(v_costo_total, 0)) / p_precio_nuevo) * 100, 2);
  
  INSERT INTO historial_precios (
    servicio_id, precio_anterior, precio_nuevo, 
    costo_total_momento, margen_momento, motivo, aplicado_por
  ) VALUES (
    p_servicio_id, p_precio_anterior, p_precio_nuevo,
    v_costo_total, v_margen, p_motivo, p_user_id
  ) RETURNING id INTO v_id;
  
  RETURN v_id;
END;
$$ LANGUAGE plpgsql;
```

---

### Row Level Security (RLS)

```sql
-- Habilitar RLS en todas las tablas
ALTER TABLE tipos_costo ENABLE ROW LEVEL SECURITY;
ALTER TABLE recursos ENABLE ROW LEVEL SECURITY;
ALTER TABLE costos_servicio ENABLE ROW LEVEL SECURITY;
ALTER TABLE costos_fijos ENABLE ROW LEVEL SECURITY;
ALTER TABLE config_margenes ENABLE ROW LEVEL SECURITY;
ALTER TABLE historial_precios ENABLE ROW LEVEL SECURITY;

-- Políticas: Solo admins pueden ver/modificar
CREATE POLICY admin_tipos_costo ON tipos_costo FOR ALL USING (
  auth.jwt() -> 'user_metadata' ->> 'role' = 'admin'
);
CREATE POLICY admin_recursos ON recursos FOR ALL USING (
  auth.jwt() -> 'user_metadata' ->> 'role' = 'admin'
);
CREATE POLICY admin_costos_servicio ON costos_servicio FOR ALL USING (
  auth.jwt() -> 'user_metadata' ->> 'role' = 'admin'
);
CREATE POLICY admin_costos_fijos ON costos_fijos FOR ALL USING (
  auth.jwt() -> 'user_metadata' ->> 'role' = 'admin'
);
CREATE POLICY admin_config_margenes ON config_margenes FOR ALL USING (
  auth.jwt() -> 'user_metadata' ->> 'role' = 'admin'
);
CREATE POLICY admin_historial_precios ON historial_precios FOR ALL USING (
  auth.jwt() -> 'user_metadata' ->> 'role' = 'admin'
);
```

---

### Triggers

```sql
-- Función para actualizar updated_at
CREATE OR REPLACE FUNCTION fn_update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers
CREATE TRIGGER trg_recursos_updated 
  BEFORE UPDATE ON recursos 
  FOR EACH ROW EXECUTE FUNCTION fn_update_timestamp();

CREATE TRIGGER trg_costos_servicio_updated 
  BEFORE UPDATE ON costos_servicio 
  FOR EACH ROW EXECUTE FUNCTION fn_update_timestamp();

CREATE TRIGGER trg_costos_fijos_updated 
  BEFORE UPDATE ON costos_fijos 
  FOR EACH ROW EXECUTE FUNCTION fn_update_timestamp();
```

---

## Navegación

| ⬆️ Padre             | [[Proyecto OnlyCarNLD/Datos/3.1.7 sistema_costos]]           |
| -------------------- | ---------------------------------- |
| ⬅️ Hermano anterior  | [[Proyecto OnlyCarNLD/Datos/3.1.7.4 dashboard_rentabilidad]] |
| ➡️ Hermano siguiente | [[Proyecto OnlyCarNLD/Datos/3.1.7.7 api_costos]]             |

---
