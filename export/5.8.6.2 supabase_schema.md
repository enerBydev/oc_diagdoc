---
id: 5.8.6.2
title: Supabase Schema
parent: 5.8.6
breadcrumb: 0 → 5.0 → 5.8 → 5.8.6 → 5.8.6.2
type: esquema
status: activo
last_updated: 2026-01-29 15:32
file_create: 2026-01-01 18:10
domain:
- supabase
- sql
- ubicaciones
summary: Esquema de BD para ubicaciones.
content_hash: 9eb27d73f1e47016
---

# 5.8.6.2 Supabase Schema

Esquema SQL detallado para almacenamiento de ubicaciones.

---

## Tablas

### Tabla Principal: ubicaciones_servicio

```sql
-- Historial completo de ubicaciones por servicio
CREATE TABLE ubicaciones_servicio (
  -- Identificadores
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  servicio_id UUID NOT NULL REFERENCES servicios(id) ON DELETE CASCADE,
  operador_id UUID NOT NULL REFERENCES users(id) ON DELETE SET NULL,
  
  -- Coordenadas
  lat DECIMAL(10, 8) NOT NULL,
  lng DECIMAL(11, 8) NOT NULL,
  
  -- Metadata GPS
  accuracy DECIMAL(8, 2),           -- Precisión en metros
  altitude DECIMAL(10, 2),          -- Altitud en metros
  altitude_accuracy DECIMAL(8, 2),  -- Precisión altitud
  heading DECIMAL(5, 2),            -- Dirección 0-360°
  speed DECIMAL(6, 2),              -- Velocidad m/s
  
  -- Timestamps
  device_timestamp TIMESTAMPTZ,     -- Timestamp del dispositivo
  created_at TIMESTAMPTZ DEFAULT now(),
  
  -- Flags
  es_llegada BOOLEAN DEFAULT false,
  es_inicio BOOLEAN DEFAULT false,
  
  -- Validaciones
  CONSTRAINT lat_valido CHECK (lat BETWEEN -90 AND 90),
  CONSTRAINT lng_valido CHECK (lng BETWEEN -180 AND 180),
  CONSTRAINT heading_valido CHECK (heading IS NULL OR heading BETWEEN 0 AND 360),
  CONSTRAINT speed_valido CHECK (speed IS NULL OR speed >= 0)
);

-- Comentarios para documentación
COMMENT ON TABLE ubicaciones_servicio IS 'Historial de ubicaciones GPS por servicio';
COMMENT ON COLUMN ubicaciones_servicio.accuracy IS 'Precisión del GPS en metros';
COMMENT ON COLUMN ubicaciones_servicio.heading IS 'Dirección de movimiento en grados (0=Norte)';
```

---

### Tabla: ubicacion_actual (Cache en DB)

```sql
-- Última ubicación por servicio activo (para queries rápidas)
CREATE TABLE ubicacion_actual (
  servicio_id UUID PRIMARY KEY REFERENCES servicios(id) ON DELETE CASCADE,
  operador_id UUID NOT NULL REFERENCES users(id),
  
  lat DECIMAL(10, 8) NOT NULL,
  lng DECIMAL(11, 8) NOT NULL,
  accuracy DECIMAL(8, 2),
  heading DECIMAL(5, 2),
  speed DECIMAL(6, 2),
  
  updated_at TIMESTAMPTZ DEFAULT now(),
  
  CONSTRAINT lat_valido CHECK (lat BETWEEN -90 AND 90),
  CONSTRAINT lng_valido CHECK (lng BETWEEN -180 AND 180)
);

COMMENT ON TABLE ubicacion_actual IS 'Cache de última ubicación por servicio activo';
```

---

## Índices

```sql
-- Búsquedas por servicio (más común)
CREATE INDEX idx_ubicaciones_servicio_id 
ON ubicaciones_servicio(servicio_id);

-- Ordenar por tiempo (historial)
CREATE INDEX idx_ubicaciones_timestamp 
ON ubicaciones_servicio(servicio_id, created_at DESC);

-- Búsquedas por operador (reportes)
CREATE INDEX idx_ubicaciones_operador 
ON ubicaciones_servicio(operador_id, created_at DESC);

-- Ubicaciones de llegada (analytics)
CREATE INDEX idx_ubicaciones_llegada 
ON ubicaciones_servicio(servicio_id) 
WHERE es_llegada = true;

-- Índice geoespacial (si se necesita búsqueda por área)
-- Requiere extensión PostGIS, opcional
-- CREATE INDEX idx_ubicaciones_geo 
-- ON ubicaciones_servicio USING GIST (
--   ST_SetSRID(ST_MakePoint(lng, lat), 4326)
-- );
```

---

## Vistas

```sql
-- Vista: Última ubicación por servicio activo
CREATE OR REPLACE VIEW v_ultima_ubicacion AS
SELECT DISTINCT ON (u.servicio_id)
  u.servicio_id,
  u.operador_id,
  u.lat,
  u.lng,
  u.accuracy,
  u.heading,
  u.speed,
  u.created_at as timestamp,
  s.estado as estado_servicio,
  s.cliente_id
FROM ubicaciones_servicio u
JOIN servicios s ON u.servicio_id = s.id
WHERE s.estado IN ('en_camino', 'llegado')
ORDER BY u.servicio_id, u.created_at DESC;

-- Vista: Resumen de tracking por servicio
CREATE OR REPLACE VIEW v_resumen_tracking AS
SELECT 
  servicio_id,
  operador_id,
  COUNT(*) as total_puntos,
  MIN(created_at) as inicio_tracking,
  MAX(created_at) as fin_tracking,
  EXTRACT(EPOCH FROM (MAX(created_at) - MIN(created_at))) as duracion_segundos,
  AVG(accuracy) as precision_promedio,
  AVG(speed) FILTER (WHERE speed > 0) as velocidad_promedio
FROM ubicaciones_servicio
GROUP BY servicio_id, operador_id;
```

---

## Funciones

```sql
-- Función: Calcular distancia entre dos puntos (Haversine)
CREATE OR REPLACE FUNCTION calcular_distancia(
  lat1 DECIMAL, lng1 DECIMAL,
  lat2 DECIMAL, lng2 DECIMAL
) RETURNS DECIMAL AS $$
DECLARE
  R CONSTANT DECIMAL := 6371000; -- Radio Tierra en metros
  phi1 DECIMAL;
  phi2 DECIMAL;
  delta_phi DECIMAL;
  delta_lambda DECIMAL;
  a DECIMAL;
  c DECIMAL;
BEGIN
  phi1 := RADIANS(lat1);
  phi2 := RADIANS(lat2);
  delta_phi := RADIANS(lat2 - lat1);
  delta_lambda := RADIANS(lng2 - lng1);
  
  a := SIN(delta_phi/2)^2 + COS(phi1) * COS(phi2) * SIN(delta_lambda/2)^2;
  c := 2 * ATAN2(SQRT(a), SQRT(1-a));
  
  RETURN R * c;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Función: Calcular distancia recorrida en un servicio
CREATE OR REPLACE FUNCTION distancia_recorrida(p_servicio_id UUID)
RETURNS DECIMAL AS $$
DECLARE
  total DECIMAL := 0;
  prev_lat DECIMAL;
  prev_lng DECIMAL;
  curr RECORD;
BEGIN
  FOR curr IN 
    SELECT lat, lng 
    FROM ubicaciones_servicio 
    WHERE servicio_id = p_servicio_id 
    ORDER BY created_at
  LOOP
    IF prev_lat IS NOT NULL THEN
      total := total + calcular_distancia(prev_lat, prev_lng, curr.lat, curr.lng);
    END IF;
    prev_lat := curr.lat;
    prev_lng := curr.lng;
  END LOOP;
  
  RETURN total;
END;
$$ LANGUAGE plpgsql;
```

---

## Triggers

```sql
-- Trigger: Actualizar ubicacion_actual automáticamente
CREATE OR REPLACE FUNCTION actualizar_ubicacion_actual()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO ubicacion_actual (
    servicio_id, operador_id, lat, lng, accuracy, heading, speed, updated_at
  ) VALUES (
    NEW.servicio_id, NEW.operador_id, NEW.lat, NEW.lng, 
    NEW.accuracy, NEW.heading, NEW.speed, NOW()
  )
  ON CONFLICT (servicio_id) DO UPDATE SET
    lat = EXCLUDED.lat,
    lng = EXCLUDED.lng,
    accuracy = EXCLUDED.accuracy,
    heading = EXCLUDED.heading,
    speed = EXCLUDED.speed,
    updated_at = NOW();
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_actualizar_ubicacion_actual
AFTER INSERT ON ubicaciones_servicio
FOR EACH ROW
EXECUTE FUNCTION actualizar_ubicacion_actual();

-- Trigger: Limpiar ubicacion_actual cuando servicio termina
CREATE OR REPLACE FUNCTION limpiar_ubicacion_actual()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.estado NOT IN ('en_camino', 'llegado') THEN
    DELETE FROM ubicacion_actual WHERE servicio_id = NEW.id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_limpiar_ubicacion_servicio_terminado
AFTER UPDATE OF estado ON servicios
FOR EACH ROW
EXECUTE FUNCTION limpiar_ubicacion_actual();
```

---

## Limpieza Automática

```sql
-- Función: Limpiar ubicaciones antiguas (cron job)
CREATE OR REPLACE FUNCTION limpiar_ubicaciones_antiguas()
RETURNS INTEGER AS $$
DECLARE
  deleted INTEGER;
BEGIN
  -- Mantener solo últimos 30 días de historial
  DELETE FROM ubicaciones_servicio
  WHERE created_at < NOW() - INTERVAL '30 days'
  AND es_llegada = false;
  
  GET DIAGNOSTICS deleted = ROW_COUNT;
  RETURN deleted;
END;
$$ LANGUAGE plpgsql;

-- Ejecutar con pg_cron (si está disponible)
-- SELECT cron.schedule('limpiar-ubicaciones', '0 3 * * *', 'SELECT limpiar_ubicaciones_antiguas()');
```

---

→ Ver políticas RLS: [[Proyecto OnlyCarNLD/Datos/5.8.6.3 rls_policies]]

---

## Navegación

| ⬆️ Padre             | [[Proyecto OnlyCarNLD/Datos/5.8.6 backend_ubicaciones]]            |
| -------------------- | ---------------------- |
| ⬅️ Hermano anterior  | [[Proyecto OnlyCarNLD/Datos/5.8.6.1 nitro_endpoints]]              |
| ➡️ Hermano siguiente | [[Proyecto OnlyCarNLD/Datos/5.8.6.3 rls_policies]]              |
