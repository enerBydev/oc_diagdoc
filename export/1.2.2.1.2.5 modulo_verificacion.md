---
id: 1.2.2.1.2.5
title: MÃ³dulo de VerificaciÃ³n
parent: 1.2.2.1.2
breadcrumb: 0 â†’ 1.0 â†’ 1.2 â†’ 1.2.2 â†’ 1.2.2.1 â†’ 1.2.2.1.2 â†’ 1.2.2.1.2.5
type: hoja
status: activo
last_updated: 2026-01-29 15:31
file_create: 2025-12-27 00:25
domain:
- operador
- verificacion
- arquitectura
- strategy_pattern
summary: 'Arquitectura abstracta para providers de verificaciÃ³n intercambiables.

  Strategy Pattern + Factory: Manual (activo) o Veriff (preparado).

  '
content_hash: 99d4eab97a5a0304
---

# 1.2.2.1.2.5 MÃ³dulo de VerificaciÃ³n

> Arquitectura abstracta para providers de verificaciÃ³n intercambiables.

---

## PatrÃ³n de DiseÃ±o

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STRATEGY PATTERN + FACTORY                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Interface IVerificationProvider                                â”‚
â”‚       â†“                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚  â”‚ ManualProviderâ”‚    â”‚ VeriffProviderâ”‚                         â”‚
â”‚  â”‚  (activo)     â”‚    â”‚  (preparado)  â”‚                         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
â”‚       â†‘                      â†‘                                  â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                  â”‚
â”‚                    â”‚                                            â”‚
â”‚           VerificationFactory                                   â”‚
â”‚           (lee config_global)                                   â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Interface

```typescript
// types/verification.ts
export interface IdentityData {
  solicitudId: string;
  nombre: string;
  apellidos: string;
  documentos?: {
    ine_frente?: string;
    ine_reverso?: string;
    curp?: string;
    domicilio?: string;
    selfie?: string;
  };
}

export interface VerificationResult {
  status: 'pending' | 'approved' | 'declined' | 'resubmission';
  sessionId?: string;
  sessionUrl?: string;
  message?: string;
  details?: Record<string, any>;
}

export interface IVerificationProvider {
  name: string;
  
  // Iniciar verificaciÃ³n
  startVerification(data: IdentityData): Promise<VerificationResult>;
  
  // Obtener estado (para polling o despuÃ©s de webhook)
  getStatus(sessionId: string): Promise<VerificationResult>;
  
  // Cancelar verificaciÃ³n en curso
  cancelVerification(sessionId: string): Promise<void>;
}
```

---


## ImplementaciÃ³n Manual

```typescript
// providers/ManualVerificationProvider.ts
export class ManualVerificationProvider implements IVerificationProvider {
  name = 'manual';
  
  async startVerification(data: IdentityData): Promise<VerificationResult> {
    // La verificaciÃ³n manual no crea sesiÃ³n externa
    // Solo marca la solicitud como "esperando revisiÃ³n admin"
    
    await supabase
      .from('operador_solicitudes')
      .update({ estado: 'documentos_enviados' })
      .eq('id', data.solicitudId);
    
    // Notificar a admins
    await notifyAdmins('NUEVA_VERIFICACION', {
      solicitudId: data.solicitudId,
      nombre: `${data.nombre} ${data.apellidos}`
    });
    
    return {
      status: 'pending',
      message: 'Documentos enviados, esperando verificaciÃ³n del administrador.'
    };
  }
  
  async getStatus(solicitudId: string): Promise<VerificationResult> {
    const { data } = await supabase
      .from('operador_solicitudes')
      .select('estado')
      .eq('id', solicitudId)
      .single();
    
    const statusMap: Record<string, VerificationResult['status']> = {
      'documentos_enviados': 'pending',
      'documentos_aprobados': 'approved',
      'documentos_rechazados': 'declined'
    };
    
    return {
      status: statusMap[data.estado] || 'pending'
    };
  }
  
  async cancelVerification(solicitudId: string): Promise<void> {
    await supabase
      .from('operador_solicitudes')
      .update({ estado: 'documentos_pendientes' })
      .eq('id', solicitudId);
  }
}
```

---

## ImplementaciÃ³n Veriff (Stub)

```typescript
// providers/VeriffVerificationProvider.ts
export class VeriffVerificationProvider implements IVerificationProvider {
  name = 'veriff';
  private config: VeriffConfig;
  
  constructor(config: VeriffConfig) {
    this.config = config;
  }
  
  async startVerification(data: IdentityData): Promise<VerificationResult> {
    // Crear sesiÃ³n en Veriff API
    const response = await $fetch(`${this.config.base_url}/sessions`, {
      method: 'POST',
      headers: {
        'X-AUTH-CLIENT': this.config.api_key
      },
      body: {
        verification: {
          person: {
            firstName: data.nombre,
            lastName: data.apellidos
          },
          vendorData: data.solicitudId
        }
      }
    });
    
    return {
      status: 'pending',
      sessionId: response.verification.id,
      sessionUrl: response.verification.url
    };
  }
  
  async getStatus(sessionId: string): Promise<VerificationResult> {
    const response = await $fetch(
      `${this.config.base_url}/sessions/${sessionId}`,
      {
        headers: { 'X-AUTH-CLIENT': this.config.api_key }
      }
    );
    
    return {
      status: response.verification.status,
      details: response.verification
    };
  }
  
  async cancelVerification(sessionId: string): Promise<void> {
    // Veriff no permite cancelar sesiones, solo ignorar
  }
}
```

---

## Factory

```typescript
// factories/verificationFactory.ts
export const getVerificationProvider = async (): Promise<IVerificationProvider> => {
  const config = await getRemoteConfig('verificacion_identidad');
  
  switch (config.provider) {
    case 'veriff':
      if (!config.veriff?.enabled) {
        console.warn('Veriff configurado pero no habilitado, usando manual');
        return new ManualVerificationProvider();
      }
      return new VeriffVerificationProvider(config.veriff);
    
    case 'manual':
    default:
      return new ManualVerificationProvider();
  }
};
```

---

## Uso en la AplicaciÃ³n

```typescript
// En cualquier parte del cÃ³digo:
const startVerification = async (solicitudId: string, data: IdentityData) => {
  const provider = await getVerificationProvider();
  
  console.log(`Usando provider: ${provider.name}`);
  
  const result = await provider.startVerification(data);
  
  if (result.sessionUrl) {
    // Veriff: abrir WebView
    openVeriffSession(result.sessionUrl);
  } else {
    // Manual: mostrar mensaje de espera
    showPendingMessage();
  }
  
  return result;
};
```

---
## NavegaciÃ³n

| â¬†ï¸ Padre             | [[Proyecto OnlyCarNLD/Datos/1.2.2.1.2 verificacion_identidad]]  |
| -------------------- | ------------------------------------- |
| â¬…ï¸ Hermano anterior  | [[Proyecto OnlyCarNLD/Datos/1.2.2.1.2.4 integracion_veriff]]    |
| ğŸ”— Ver tambiÃ©n       | [[Proyecto OnlyCarNLD/Datos/1.2.2.1.3.3 modulo_antecedentes]]   |

---
