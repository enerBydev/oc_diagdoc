---
id: '7.4'
title: Patrones Repository y Strategy
parent: '7.0'
breadcrumb: 0 → 7.0 → 7.4
type: modulo_padre
children_count: 2
descendants_count: 2
domain:
- repository-pattern
- strategy-pattern
- design-patterns
actors:
- desarrollador
status: activo
last_updated: 2026-01-29 15:32
file_create: 2026-01-21 12:36
summary: 'Patrones de diseño fundamentales: Repository para persistencia y Strategy
  para algoritmos intercambiables.

  '
content_hash: 48ca19b000a59d8c
---

# 7.4 Patrones Repository y Strategy

> Patrones de diseño fundamentales para desacoplamiento y flexibilidad.

---

## Repository Pattern

### Propósito

Abstrae el acceso a datos, permitiendo cambiar la fuente de datos sin modificar la lógica de negocio.

### Interfaz

```typescript
// domain/ports/outbound/ICitaRepository.ts
interface ICitaRepository {
  findById(id: string): Promise<Cita | null>;
  findByOperador(operadorId: string): Promise<Cita[]>;
  findByCliente(clienteId: string): Promise<Cita[]>;
  save(cita: Cita): Promise<void>;
  delete(id: string): Promise<void>;
}
```

### Implementaciones

```typescript
// infrastructure/adapters/persistence/SupabaseCitaRepository.ts
class SupabaseCitaRepository implements ICitaRepository {
  constructor(private supabase: SupabaseClient) {}
  
  async findById(id: string): Promise<Cita | null> {
    const { data } = await this.supabase
      .from('citas')
      .select('*')
      .eq('id', id)
      .single();
    return data ? CitaMapper.toDomain(data) : null;
  }
}

// infrastructure/adapters/persistence/DexieCitaRepository.ts
class DexieCitaRepository implements ICitaRepository {
  // Implementación para offline con IndexedDB
}
```

---

## Strategy Pattern

### Propósito

Permite intercambiar algoritmos en tiempo de ejecución sin modificar el código cliente.

### Ejemplo: Pricing Strategies

```typescript
// domain/ports/outbound/IPricingStrategy.ts
interface IPricingStrategy {
  calculate(basePrice: number, context: PricingContext): number;
}

// Estrategias concretas
class StandardPricingStrategy implements IPricingStrategy {
  calculate(basePrice: number, context: PricingContext): number {
    return basePrice;
  }
}

class DynamicPricingStrategy implements IPricingStrategy {
  calculate(basePrice: number, context: PricingContext): number {
    const demandMultiplier = this.getDemandMultiplier(context);
    return basePrice * demandMultiplier;
  }
}

class CorporatePricingStrategy implements IPricingStrategy {
  calculate(basePrice: number, context: PricingContext): number {
    const discount = context.contratoB2B?.descuento || 0;
    return basePrice * (1 - discount);
  }
}
```

---

## Estructura de Hijos

| ID | Nombre | Descripción | Estado |
|----|--------|-------------|--------|
| [[Proyecto OnlyCarNLD/Datos/7.4.1 Repository_Pattern\|7.4.1]] | Repository Pattern | Abstracción de persistencia | ✅ |
| [[Proyecto OnlyCarNLD/Datos/7.4.2 Strategy_Pattern\|7.4.2]] | Strategy Pattern | Algoritmos intercambiables | ✅ |

---

## Navegación

| ⬆️ Padre | [[Proyecto OnlyCarNLD/Datos/7.0. arquitectura]] |
|----------|----------------------|
| ⬅️ Anterior | [[Proyecto OnlyCarNLD/Datos/7.3 Atomic_Design_System]] |
| ➡️ Siguiente | [[Proyecto OnlyCarNLD/Datos/7.5 TDD_Testing_Strategy]] |

---
