---
id: 5.8.8.1
title: Unit Tests
parent: 5.8.8
breadcrumb: 0 → 5.0 → 5.8 → 5.8.8 → 5.8.8.1
type: testing
status: activo
last_updated: 2026-01-29 15:32
file_create: 2026-01-01 18:10
domain:
- unit
- vitest
- mocks
summary: Pruebas unitarias de geo.
content_hash: 47ea27a21978f367
---

# 5.8.8.1 Unit Tests

Tests unitarios para composables y utilities de geolocalización.

---

## Estructura de Tests

```
tests/
├── unit/
│   └── geo/
│       ├── useGeolocation.test.ts
│       ├── useLocationBroadcast.test.ts
│       ├── useArrivalDetection.test.ts
│       ├── useGeoUtils.test.ts
│       ├── useOfflineQueue.test.ts
│       └── useDeviceLock.test.ts
└── __mocks__/
    └── capacitor-geolocation.ts
```

---

## Test: useGeolocation

```typescript
// tests/unit/geo/useGeolocation.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { Geolocation } from '@capacitor/geolocation';
import { useGeolocation } from '~/composables/useGeolocation';

describe('useGeolocation', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });
  
  describe('getCurrentPosition', () => {
    it('should return position when GPS available', async () => {
      vi.mocked(Geolocation.getCurrentPosition).mockResolvedValue({
        coords: {
          latitude: 27.4797,
          longitude: -99.5067,
          accuracy: 10,
          altitude: null,
          altitudeAccuracy: null,
          heading: null,
          speed: null
        },
        timestamp: Date.now()
      });
      
      const { getCurrentPosition, position, error } = useGeolocation();
      
      await getCurrentPosition();
      
      expect(position.value).toEqual({
        lat: 27.4797,
        lng: -99.5067,
        accuracy: 10
      });
      expect(error.value).toBeNull();
    });
    
    it('should set error when GPS fails', async () => {
      vi.mocked(Geolocation.getCurrentPosition).mockRejectedValue(
        new Error('Position unavailable')
      );
      
      const { getCurrentPosition, error } = useGeolocation();
      
      await expect(getCurrentPosition()).rejects.toThrow('Position unavailable');
      expect(error.value).toBe('Position unavailable');
    });
  });
  
  describe('startTracking', () => {
    it('should set isTracking to true', async () => {
      vi.mocked(Geolocation.watchPosition).mockResolvedValue('watch-id-123');
      
      const { startTracking, isTracking } = useGeolocation();
      
      await startTracking();
      
      expect(isTracking.value).toBe(true);
    });
    
    it('should call callback on position update', async () => {
      const callback = vi.fn();
      let watchCallback: Function;
      
      vi.mocked(Geolocation.watchPosition).mockImplementation(
        async (options, cb) => {
          watchCallback = cb;
          return 'watch-id';
        }
      );
      
      const { startTracking } = useGeolocation();
      await startTracking(callback);
      
      // Simular un update de posición
      watchCallback({
        coords: {
          latitude: 27.5,
          longitude: -99.5,
          accuracy: 5
        }
      });
      
      expect(callback).toHaveBeenCalledWith({
        lat: 27.5,
        lng: -99.5,
        accuracy: 5
      });
    });
  });
  
  describe('stopTracking', () => {
    it('should clear watch and set isTracking to false', async () => {
      vi.mocked(Geolocation.watchPosition).mockResolvedValue('watch-id-123');
      vi.mocked(Geolocation.clearWatch).mockResolvedValue();
      
      const { startTracking, stopTracking, isTracking } = useGeolocation();
      
      await startTracking();
      expect(isTracking.value).toBe(true);
      
      await stopTracking();
      expect(isTracking.value).toBe(false);
      expect(Geolocation.clearWatch).toHaveBeenCalledWith({ id: 'watch-id-123' });
    });
  });
});
```

---

## Test: useGeoUtils (Haversine)

```typescript
// tests/unit/geo/useGeoUtils.test.ts
import { describe, it, expect } from 'vitest';
import { calcularDistancia, calcularBearing, estimarTiempoLlegada } from '~/utils/geoUtils';

describe('geoUtils', () => {
  describe('calcularDistancia', () => {
    it('should calculate distance between two points correctly', () => {
      // Puntos conocidos en Nuevo Laredo
      const puntoA = { lat: 27.4797, lng: -99.5067 };
      const puntoB = { lat: 27.5000, lng: -99.5200 };
      
      const distancia = calcularDistancia(
        puntoA.lat, puntoA.lng,
        puntoB.lat, puntoB.lng
      );
      
      // Distancia aproximada: 2.5-3 km
      expect(distancia).toBeGreaterThan(2000);
      expect(distancia).toBeLessThan(4000);
    });
    
    it('should return 0 for same point', () => {
      const distancia = calcularDistancia(27.5, -99.5, 27.5, -99.5);
      expect(distancia).toBe(0);
    });
    
    it('should handle edge coordinates', () => {
      // Polo Norte a Ecuador
      const distancia = calcularDistancia(90, 0, 0, 0);
      
      // ~10,000 km
      expect(distancia).toBeGreaterThan(9_900_000);
      expect(distancia).toBeLessThan(10_100_000);
    });
  });
  
  describe('calcularBearing', () => {
    it('should return ~0 for north direction', () => {
      const bearing = calcularBearing(27.4, -99.5, 27.5, -99.5);
      expect(bearing).toBeCloseTo(0, 0);
    });
    
    it('should return ~90 for east direction', () => {
      const bearing = calcularBearing(27.5, -99.5, 27.5, -99.4);
      expect(bearing).toBeCloseTo(90, 0);
    });
    
    it('should return ~180 for south direction', () => {
      const bearing = calcularBearing(27.5, -99.5, 27.4, -99.5);
      expect(bearing).toBeCloseTo(180, 0);
    });
  });
  
  describe('estimarTiempoLlegada', () => {
    it('should estimate time based on distance', () => {
      // 3 km a 30 km/h = 6 minutos
      const eta = estimarTiempoLlegada(3000, 30);
      expect(eta).toBe(6);
    });
    
    it('should round up minutes', () => {
      // 2.5 km a 30 km/h = 5 minutos
      const eta = estimarTiempoLlegada(2500, 30);
      expect(eta).toBe(5);
    });
  });
});
```

---

## Test: useArrivalDetection

```typescript
// tests/unit/geo/useArrivalDetection.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { ref } from 'vue';
import { useArrivalDetection } from '~/composables/useArrivalDetection';

describe('useArrivalDetection', () => {
  const destino = ref({ lat: 27.4797, lng: -99.5067 });
  
  beforeEach(() => {
    destino.value = { lat: 27.4797, lng: -99.5067 };
  });
  
  it('should not detect arrival when far from destination', () => {
    const { checkArrival, hasArrived, state } = useArrivalDetection(destino);
    
    // 1 km de distancia
    const arrived = checkArrival(27.4897, -99.5067);
    
    expect(arrived).toBe(false);
    expect(hasArrived.value).toBe(false);
    expect(state.distanceToDestino).toBeGreaterThan(100);
  });
  
  it('should detect arrival when within threshold', () => {
    const { checkArrival, hasArrived, state } = useArrivalDetection(destino);
    
    // Muy cerca (50m)
    checkArrival(27.4800, -99.5067); // Primera confirmación
    checkArrival(27.4800, -99.5067); // Segunda confirmación
    
    expect(hasArrived.value).toBe(true);
    expect(state.arrivedAt).not.toBeNull();
  });
  
  it('should require multiple confirmations', () => {
    const { checkArrival, hasArrived, state } = useArrivalDetection(destino);
    
    // Solo una lectura cerca
    checkArrival(27.4800, -99.5067);
    
    expect(hasArrived.value).toBe(false);
    expect(state.confirmationCount).toBe(1);
  });
  
  it('should reset confirmations when moving away', () => {
    const { checkArrival, state } = useArrivalDetection(destino);
    
    // Cerca
    checkArrival(27.4800, -99.5067);
    expect(state.confirmationCount).toBe(1);
    
    // Lejos
    checkArrival(27.5000, -99.5067);
    expect(state.confirmationCount).toBe(0);
  });
  
  it('should allow manual confirmation', () => {
    const { confirmArrival, hasArrived } = useArrivalDetection(destino);
    
    confirmArrival();
    
    expect(hasArrived.value).toBe(true);
  });
});
```

---

## Test: useOfflineQueue

```typescript
// tests/unit/geo/useOfflineQueue.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useOfflineQueue } from '~/composables/useOfflineQueue';

describe('useOfflineQueue', () => {
  beforeEach(() => {
    localStorage.clear();
  });
  
  it('should enqueue location when offline', () => {
    const { enqueue, queueSize } = useOfflineQueue();
    
    enqueue({
      lat: 27.5,
      lng: -99.5,
      accuracy: 10,
      timestamp: Date.now(),
      servicioId: 'test-service'
    });
    
    expect(queueSize.value).toBe(1);
  });
  
  it('should limit queue size to MAX_QUEUE_SIZE', () => {
    const { enqueue, queueSize, queue } = useOfflineQueue();
    
    // Encolar más del límite
    for (let i = 0; i < 120; i++) {
      enqueue({
        lat: 27.5 + i * 0.001,
        lng: -99.5,
        accuracy: 10,
        timestamp: Date.now() + i,
        servicioId: 'test-service'
      });
    }
    
    expect(queueSize.value).toBe(100);
    // El primero debería haber sido removido
    expect(queue.value[0].lat).toBeGreaterThan(27.5);
  });
  
  it('should persist queue to localStorage', () => {
    const { enqueue } = useOfflineQueue();
    
    enqueue({
      lat: 27.5,
      lng: -99.5,
      accuracy: 10,
      timestamp: 12345,
      servicioId: 'test-service'
    });
    
    const saved = localStorage.getItem('offline_location_queue');
    expect(saved).not.toBeNull();
    
    const parsed = JSON.parse(saved!);
    expect(parsed).toHaveLength(1);
    expect(parsed[0].lat).toBe(27.5);
  });
});
```

---

→ Ver integration tests: [[Proyecto OnlyCarNLD/Datos/5.8.8.2 integration_tests]]

---

## Navegación

| ⬆️ Padre             | [[Proyecto OnlyCarNLD/Datos/5.8.8 testing]]             |
| -------------------- | ----------------------------- |
| ➡️ Hermano siguiente | [[Proyecto OnlyCarNLD/Datos/5.8.8.2 integration_tests]] |
