---
id: 5.8.7.2
title: Network Offline
parent: 5.8.7
breadcrumb: 0 ‚Üí 5.0 ‚Üí 5.8 ‚Üí 5.8.7 ‚Üí 5.8.7.2
type: edge_case
status: activo
last_updated: 2026-01-29 15:31
file_create: 2026-01-01 18:10
domain:
- offline
- network
- queue
summary: Manejo sin conexi√≥n a internet.
content_hash: 3579e9b22f039461
---

# 5.8.7.2 Network Offline

Manejo cuando el dispositivo pierde conexi√≥n a internet.

---

## Escenarios

| Escenario | Detecci√≥n | Impacto |
|-----------|-----------|---------|
| Sin datos m√≥viles | Network API | No puede broadcast |
| WiFi perdido | Network API | No puede broadcast |
| Conexi√≥n lenta | Timeout | Broadcasts retrasados |
| Intermitente | Fallos aleatorios | Cola de reintentos |

---

## Detecci√≥n de Conectividad

```typescript
// composables/useNetworkStatus.ts
import { Network } from '@capacitor/network';

interface NetworkState {
  connected: boolean;
  connectionType: 'wifi' | 'cellular' | 'none' | 'unknown';
  isMetered: boolean;
}

export const useNetworkStatus = () => {
  const state = reactive<NetworkState>({
    connected: true,
    connectionType: 'unknown',
    isMetered: false
  });
  
  const checkStatus = async () => {
    const status = await Network.getStatus();
    state.connected = status.connected;
    state.connectionType = status.connectionType;
  };
  
  // Escuchar cambios
  onMounted(async () => {
    await checkStatus();
    
    Network.addListener('networkStatusChange', (status) => {
      state.connected = status.connected;
      state.connectionType = status.connectionType;
      
      if (status.connected) {
        // Reconectado: procesar cola
        processOfflineQueue();
      }
    });
  });
  
  onUnmounted(() => {
    Network.removeAllListeners();
  });
  
  return {
    state: readonly(state),
    checkStatus
  };
};
```

---

## Cola Offline

```typescript
// composables/useOfflineQueue.ts
interface QueuedLocation {
  lat: number;
  lng: number;
  accuracy: number;
  timestamp: number;
  servicioId: string;
}

const QUEUE_KEY = 'offline_location_queue';
const MAX_QUEUE_SIZE = 100;

export const useOfflineQueue = () => {
  const queue = ref<QueuedLocation[]>([]);
  
  // Cargar cola desde storage
  onMounted(() => {
    const saved = localStorage.getItem(QUEUE_KEY);
    if (saved) {
      queue.value = JSON.parse(saved);
    }
  });
  
  // Guardar cola en storage
  const saveQueue = () => {
    localStorage.setItem(QUEUE_KEY, JSON.stringify(queue.value));
  };
  
  // Agregar a cola
  const enqueue = (location: QueuedLocation) => {
    // Limitar tama√±o de cola
    if (queue.value.length >= MAX_QUEUE_SIZE) {
      queue.value.shift(); // Remover m√°s antiguo
    }
    
    queue.value.push(location);
    saveQueue();
  };
  
  // Procesar cola cuando hay conexi√≥n
  const processQueue = async () => {
    if (queue.value.length === 0) return;
    
    const { broadcastLocation } = useLocationBroadcast(queue.value[0].servicioId);
    
    const toProcess = [...queue.value];
    queue.value = [];
    saveQueue();
    
    for (const location of toProcess) {
      try {
        await broadcastLocation(location.lat, location.lng, location.accuracy);
      } catch (error) {
        // Si falla, volver a encolar
        enqueue(location);
        break; // Parar si hay error
      }
    }
  };
  
  return {
    queue: readonly(queue),
    queueSize: computed(() => queue.value.length),
    enqueue,
    processQueue,
    clearQueue: () => {
      queue.value = [];
      saveQueue();
    }
  };
};
```

---

## Integraci√≥n con Tracking

```typescript
// En el composable principal de tracking
const { state: networkState } = useNetworkStatus();
const { enqueue, processQueue, queueSize } = useOfflineQueue();
const { state: geoState, incrementOfflineQueue, clearOfflineQueue } = useGeoState();

// Modificar broadcast para manejar offline
const safeBroadcast = async (lat: number, lng: number, accuracy: number) => {
  if (!networkState.connected) {
    // Sin conexi√≥n: encolar
    enqueue({
      lat, lng, accuracy,
      timestamp: Date.now(),
      servicioId: currentServicioId.value
    });
    incrementOfflineQueue();
    return;
  }
  
  try {
    await broadcastLocation(lat, lng, accuracy);
  } catch (error) {
    // Error de red: encolar
    enqueue({
      lat, lng, accuracy,
      timestamp: Date.now(),
      servicioId: currentServicioId.value
    });
    incrementOfflineQueue();
  }
};

// Cuando se reconecta
watch(() => networkState.connected, async (connected) => {
  if (connected && queueSize.value > 0) {
    await processQueue();
    clearOfflineQueue();
  }
});
```

---

## UI Offline

```vue
<!-- components/OfflineBanner.vue -->
<script setup lang="ts">
const { state } = useNetworkStatus();
const { queueSize } = useOfflineQueue();

const isVisible = computed(() => !state.connected || queueSize.value > 0);
</script>

<template>
  <Transition name="slide">
    <div v-if="isVisible" class="offline-banner">
      <template v-if="!state.connected">
        <span class="icon">üì°</span>
        <span>Sin conexi√≥n</span>
        <span class="detail">Las ubicaciones se guardar√°n localmente</span>
      </template>
      
      <template v-else-if="queueSize > 0">
        <span class="icon">üì§</span>
        <span>Sincronizando...</span>
        <span class="detail">{{ queueSize }} ubicaciones pendientes</span>
      </template>
    </div>
  </Transition>
</template>

<style scoped>
.offline-banner {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  padding: 8px 16px;
  background: var(--color-warning);
  color: var(--color-warning-text);
  display: flex;
  align-items: center;
  gap: 8px;
  z-index: 1000;
}

.slide-enter-active,
.slide-leave-active {
  transition: transform 0.3s ease;
}

.slide-enter-from,
.slide-leave-to {
  transform: translateY(-100%);
}
</style>
```

---

## Reconexi√≥n Autom√°tica con Backoff

```typescript
// utils/reconnection.ts
export const createReconnectionStrategy = () => {
  let attempts = 0;
  const MAX_ATTEMPTS = 10;
  const BASE_DELAY = 1000;
  
  const getNextDelay = (): number => {
    // Exponential backoff: 1s, 2s, 4s, 8s, 16s, 32s (max 32s)
    const delay = Math.min(BASE_DELAY * Math.pow(2, attempts), 32000);
    attempts++;
    return delay;
  };
  
  const reset = () => {
    attempts = 0;
  };
  
  const shouldRetry = (): boolean => {
    return attempts < MAX_ATTEMPTS;
  };
  
  return { getNextDelay, reset, shouldRetry };
};

// Uso
const reconnection = createReconnectionStrategy();

const attemptReconnect = async () => {
  while (reconnection.shouldRetry()) {
    const delay = reconnection.getNextDelay();
    await new Promise(r => setTimeout(r, delay));
    
    if (await tryConnect()) {
      reconnection.reset();
      return true;
    }
  }
  return false;
};
```

---

‚Üí Ver app killed: [[Proyecto OnlyCarNLD/Datos/5.8.7.3 app_killed]]

---

## Navegaci√≥n

| ‚¨ÜÔ∏è Padre             | [[Proyecto OnlyCarNLD/Datos/5.8.7 edge_cases]]            |
| -------------------- | ---------------------- |
| ‚¨ÖÔ∏è Hermano anterior  | [[Proyecto OnlyCarNLD/Datos/5.8.7.1 gps_unavailable]]              |
| ‚û°Ô∏è Hermano siguiente | [[Proyecto OnlyCarNLD/Datos/5.8.7.3 app_killed]]              |
